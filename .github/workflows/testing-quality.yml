name: ğŸ§ª Testing & Quality

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run tests daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.10'

jobs:
  code-quality:
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install black flake8 isort pytest-cov
    
    - name: ğŸ” Code formatting check (Black)
      run: |
        echo "ğŸ” Checking code formatting with Black..."
        black --check --diff scripts/ tests/ || {
          echo "âŒ Code formatting issues found. Run 'black scripts/ tests/' to fix."
          exit 1
        }
        echo "âœ… Code formatting check passed"
    
    - name: ğŸ” Import sorting check (isort)
      run: |
        echo "ğŸ” Checking import sorting with isort..."
        isort --check-only --diff scripts/ tests/ || {
          echo "âŒ Import sorting issues found. Run 'isort scripts/ tests/' to fix."
          exit 1
        }
        echo "âœ… Import sorting check passed"
    
    - name: ğŸ” Code linting (flake8)
      run: |
        echo "ğŸ” Running code linting with flake8..."
        flake8 scripts/ tests/ --max-line-length=88 --extend-ignore=E203,W503 || {
          echo "âŒ Linting issues found. Please fix the issues above."
          exit 1
        }
        echo "âœ… Code linting passed"
    
    - name: ğŸ” Security scan
      run: |
        echo "ğŸ” Running security scan..."
        pip install bandit
        bandit -r scripts/ -f json -o bandit-report.json || true
        
        # Check if any high or medium severity issues
        python -c "
        import json
        try:
            with open('bandit-report.json', 'r') as f:
                report = json.load(f)
            
            high_issues = [issue for issue in report.get('results', []) if issue['issue_severity'] == 'HIGH']
            medium_issues = [issue for issue in report.get('results', []) if issue['issue_severity'] == 'MEDIUM']
            
            if high_issues:
                print(f'âŒ {len(high_issues)} high severity security issues found')
                for issue in high_issues:
                    print(f'  - {issue[\"test_name\"]}: {issue[\"issue_text\"]}')
                exit(1)
            elif medium_issues:
                print(f'âš ï¸ {len(medium_issues)} medium severity security issues found')
                for issue in medium_issues:
                    print(f'  - {issue[\"test_name\"]}: {issue[\"issue_text\"]}')
            else:
                print('âœ… No high or medium severity security issues found')
        except FileNotFoundError:
            print('âš ï¸ Security scan report not found')
        except Exception as e:
            print(f'âš ï¸ Error processing security scan: {e}')
        "

  unit-tests:
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-mock
    
    - name: ğŸ“ Create test data
      run: |
        echo "ğŸ“ Creating test data..."
        mkdir -p tests/data
        
        # Create minimal test datasets
        python -c "
        import pandas as pd
        import numpy as np
        
        # Create test feature data
        np.random.seed(42)
        n_samples = 100
        
        # Mix of categorical and numerical data
        X_test = pd.DataFrame({
            'Attribute1': np.random.choice(['A11', 'A12', 'A13', 'A14'], n_samples),
            'Attribute2': np.random.randint(4, 73, n_samples),
            'Attribute3': np.random.choice(['A30', 'A31', 'A32', 'A33', 'A34'], n_samples),
            'Attribute4': np.random.choice(['A40', 'A41', 'A42', 'A43'], n_samples),
            'Attribute5': np.random.randint(250, 18425, n_samples),
        })
        
        # Add more attributes to match original structure
        for i in range(6, 21):
            if i in [8, 11, 13, 16, 18]:  # numerical attributes
                X_test[f'Attribute{i}'] = np.random.randint(1, 5, n_samples)
            else:  # categorical attributes
                X_test[f'Attribute{i}'] = np.random.choice(['A' + str(i) + str(j) for j in range(1, 4)], n_samples)
        
        # Create test target data
        y_test = pd.DataFrame({
            'class': np.random.choice([1, 2], n_samples, p=[0.7, 0.3])
        })
        
        # Save test data
        X_test.to_csv('tests/data/X_test.csv', index=False)
        y_test.to_csv('tests/data/y_test.csv', index=False)
        
        print(f'âœ… Created test data: {X_test.shape[0]} samples, {X_test.shape[1]} features')
        "
    
    - name: ğŸ§ª Run unit tests
      run: |
        echo "ğŸ§ª Running unit tests..."
        
        # Create basic test files if they don't exist
        mkdir -p tests
        
        # Test preprocessing functionality
        cat > tests/test_preprocessing.py << 'EOF'
        import pytest
        import pandas as pd
        import numpy as np
        import sys
        import os
        sys.path.append('scripts')

        def test_data_loading():
            """Test that test data can be loaded"""
            X = pd.read_csv('tests/data/X_test.csv')
            y = pd.read_csv('tests/data/y_test.csv')
            
            assert X.shape[0] > 0, "X dataset should not be empty"
            assert y.shape[0] > 0, "y dataset should not be empty"
            assert X.shape[0] == y.shape[0], "X and y should have same number of samples"

        def test_data_types():
            """Test data types are correct"""
            X = pd.read_csv('tests/data/X_test.csv')
            y = pd.read_csv('tests/data/y_test.csv')
            
            # Check that we have both categorical and numerical columns
            categorical_cols = X.select_dtypes(include=['object']).columns
            numerical_cols = X.select_dtypes(include=['int64', 'float64']).columns
            
            assert len(categorical_cols) > 0, "Should have categorical columns"
            assert len(numerical_cols) > 0, "Should have numerical columns"
            
            # Check target values
            unique_targets = y.iloc[:, 0].unique()
            assert len(unique_targets) <= 2, "Should be binary classification"

        def test_preprocessing_pipeline():
            """Test preprocessing pipeline components"""
            from sklearn.preprocessing import LabelEncoder, StandardScaler
            from sklearn.model_selection import train_test_split
            
            X = pd.read_csv('tests/data/X_test.csv')
            y = pd.read_csv('tests/data/y_test.csv').iloc[:, 0]
            
            # Test label encoding
            categorical_cols = X.select_dtypes(include=['object']).columns
            for col in categorical_cols:
                le = LabelEncoder()
                encoded = le.fit_transform(X[col])
                assert len(encoded) == len(X[col]), f"Encoding failed for {col}"
            
            # Test train/test split
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            assert len(X_train) > len(X_test), "Training set should be larger"
            assert len(X_train) + len(X_test) == len(X), "No samples should be lost"
        EOF
        
        # Test model functionality
        cat > tests/test_model.py << 'EOF'
        import pytest
        import pandas as pd
        import numpy as np
        from sklearn.ensemble import RandomForestClassifier
        from sklearn.preprocessing import LabelEncoder
        from sklearn.model_selection import train_test_split
        from sklearn.metrics import accuracy_score
        import sys
        sys.path.append('scripts')

        def test_model_training():
            """Test that model can be trained"""
            X = pd.read_csv('tests/data/X_test.csv')
            y = pd.read_csv('tests/data/y_test.csv').iloc[:, 0]
            
            # Encode categorical variables
            categorical_cols = X.select_dtypes(include=['object']).columns
            for col in categorical_cols:
                le = LabelEncoder()
                X[col] = le.fit_transform(X[col])
            
            # Split data
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            
            # Train model
            model = RandomForestClassifier(n_estimators=10, random_state=42)
            model.fit(X_train, y_train)
            
            # Test predictions
            y_pred = model.predict(X_test)
            accuracy = accuracy_score(y_test, y_pred)
            
            assert accuracy >= 0.0, "Accuracy should be non-negative"
            assert accuracy <= 1.0, "Accuracy should not exceed 1.0"
            assert len(y_pred) == len(y_test), "Predictions should match test size"

        def test_model_parameters():
            """Test model parameter validation"""
            # Test valid parameters
            valid_params = {
                'n_estimators': 100,
                'max_depth': 10,
                'min_samples_split': 5,
                'min_samples_leaf': 2,
                'random_state': 42
            }
            
            model = RandomForestClassifier(**valid_params)
            assert model.n_estimators == 100
            assert model.max_depth == 10
            assert model.random_state == 42

        def test_feature_importance():
            """Test feature importance extraction"""
            X = pd.read_csv('tests/data/X_test.csv')
            y = pd.read_csv('tests/data/y_test.csv').iloc[:, 0]
            
            # Encode categorical variables
            categorical_cols = X.select_dtypes(include=['object']).columns
            for col in categorical_cols:
                le = LabelEncoder()
                X[col] = le.fit_transform(X[col])
            
            # Train model
            model = RandomForestClassifier(n_estimators=10, random_state=42)
            model.fit(X, y)
            
            # Test feature importance
            importance = model.feature_importances_
            assert len(importance) == X.shape[1], "Feature importance should match number of features"
            assert np.sum(importance) == pytest.approx(1.0, rel=1e-3), "Feature importance should sum to 1"
        EOF
        
        # Test pipeline functionality
        cat > tests/test_pipeline.py << 'EOF'
        import pytest
        import pandas as pd
        import numpy as np
        import yaml
        import json
        import os
        import sys
        sys.path.append('scripts')

        def test_params_loading():
            """Test parameter loading functionality"""
            # Create test params file
            test_params = {
                'data_preprocessing': {
                    'test_size': 0.2,
                    'random_state': 42,
                    'scale_features': True
                },
                'model_training': {
                    'n_estimators': 100,
                    'max_depth': 10,
                    'random_state': 42
                }
            }
            
            with open('test_params.yaml', 'w') as f:
                yaml.dump(test_params, f)
            
            # Test loading
            with open('test_params.yaml', 'r') as f:
                loaded_params = yaml.safe_load(f)
            
            assert loaded_params['data_preprocessing']['test_size'] == 0.2
            assert loaded_params['model_training']['n_estimators'] == 100
            
            # Cleanup
            os.remove('test_params.yaml')

        def test_metrics_saving():
            """Test metrics saving functionality"""
            test_metrics = {
                'accuracy': 0.78,
                'auc_score': 0.79,
                'f1_score': 0.76
            }
            
            os.makedirs('test_metrics', exist_ok=True)
            with open('test_metrics/test_metrics.json', 'w') as f:
                json.dump(test_metrics, f)
            
            # Test loading
            with open('test_metrics/test_metrics.json', 'r') as f:
                loaded_metrics = json.load(f)
            
            assert loaded_metrics['accuracy'] == 0.78
            assert 'auc_score' in loaded_metrics
            
            # Cleanup
            import shutil
            shutil.rmtree('test_metrics')

        def test_data_validation():
            """Test data validation functionality"""
            X = pd.read_csv('tests/data/X_test.csv')
            y = pd.read_csv('tests/data/y_test.csv')
            
            # Test data validation rules
            assert X.shape[0] > 50, "Should have sufficient samples for testing"
            assert X.shape[1] >= 5, "Should have multiple features"
            assert not X.isnull().all().any(), "No column should be entirely null"
            assert y.shape[0] == X.shape[0], "Target should match features"
        EOF
        
        # Run the tests
        pytest tests/ -v --tb=short --cov=scripts --cov-report=term-missing --cov-report=xml
        
        echo "âœ… Unit tests completed"
    
    - name: ğŸ“Š Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  integration-tests:
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests]
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: ğŸ”§ Configure AWS credentials (for integration tests)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-south-1
      continue-on-error: true
    
    - name: ğŸ§ª Test MLflow connection
      run: |
        echo "ğŸ§ª Testing MLflow connection..."
        python -c "
        import mlflow
        import requests
        
        mlflow_uri = 'http://ab124afa4840a4f8298398f9c7fd7c7e-306571921.ap-south-1.elb.amazonaws.com'
        mlflow.set_tracking_uri(mlflow_uri)
        
        try:
            # Test basic connection
            client = mlflow.tracking.MlflowClient()
            experiments = client.search_experiments()
            print(f'âœ… MLflow connection successful: {len(experiments)} experiments found')
        except Exception as e:
            print(f'âš ï¸ MLflow connection test failed: {e}')
            print('This is expected in CI environment without network access')
        "
    
    - name: ğŸ§ª Test DVC functionality
      run: |
        echo "ğŸ§ª Testing DVC functionality..."
        
        # Test DVC commands (without actual remote access)
        dvc version
        
        # Test DVC pipeline syntax
        if [ -f "dvc.yaml" ]; then
          echo "âœ… DVC pipeline file exists"
          python -c "
          import yaml
          with open('dvc.yaml', 'r') as f:
              pipeline = yaml.safe_load(f)
          
          assert 'stages' in pipeline, 'Pipeline should have stages'
          stages = pipeline['stages']
          assert 'data_preprocessing' in stages, 'Should have preprocessing stage'
          assert 'train_model' in stages, 'Should have training stage'
          assert 'evaluate_model' in stages, 'Should have evaluation stage'
          
          print('âœ… DVC pipeline validation passed')
          "
        else
          echo "âš ï¸ DVC pipeline file not found"
        fi
    
    - name: ğŸ§ª Test end-to-end pipeline (dry run)
      run: |
        echo "ğŸ§ª Testing end-to-end pipeline (dry run)..."
        
        # Create minimal test data
        mkdir -p data/raw
        cp tests/data/X_test.csv data/raw/X.csv
        cp tests/data/y_test.csv data/raw/y.csv
        
        # Test preprocessing script
        echo "Testing preprocessing..."
        python scripts/preprocess_data.py || echo "âš ï¸ Preprocessing test completed with warnings"
        
        # Verify outputs were created
        if [ -f "data/processed/X_processed.csv" ]; then
          echo "âœ… Preprocessing output created successfully"
        else
          echo "âš ï¸ Preprocessing output not created"
        fi
        
        echo "âœ… End-to-end pipeline test completed"

  performance-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
    
    - name: ğŸ Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: ğŸ“¦ Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install memory-profiler psutil
    
    - name: âš¡ Performance tests
      run: |
        echo "âš¡ Running performance tests..."
        
        # Test preprocessing performance
        python -c "
        import time
        import psutil
        import pandas as pd
        import numpy as np
        from sklearn.preprocessing import LabelEncoder
        
        # Create larger test dataset for performance testing
        np.random.seed(42)
        n_samples = 10000
        
        # Generate test data
        start_time = time.time()
        X_large = pd.DataFrame({
            'cat1': np.random.choice(['A', 'B', 'C', 'D'], n_samples),
            'cat2': np.random.choice(['X', 'Y', 'Z'], n_samples),
            'num1': np.random.randint(1, 100, n_samples),
            'num2': np.random.random(n_samples),
        })
        
        # Test encoding performance
        le = LabelEncoder()
        encoded = le.fit_transform(X_large['cat1'])
        
        end_time = time.time()
        processing_time = end_time - start_time
        
        print(f'âœ… Processed {n_samples} samples in {processing_time:.2f} seconds')
        print(f'âš¡ Processing rate: {n_samples/processing_time:.0f} samples/second')
        
        # Memory usage check
        process = psutil.Process()
        memory_mb = process.memory_info().rss / 1024 / 1024
        print(f'ğŸ“Š Memory usage: {memory_mb:.1f} MB')
        
        # Performance assertions
        assert processing_time < 5.0, f'Processing too slow: {processing_time:.2f}s'
        assert memory_mb < 500, f'Memory usage too high: {memory_mb:.1f}MB'
        
        print('âœ… Performance tests passed')
        "

  report:
    needs: [code-quality, unit-tests, integration-tests, performance-tests]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: ğŸ“Š Generate test report
      run: |
        echo "ğŸ“Š Generating comprehensive test report..."
        
        cat > test_report.md << EOF
        # Test & Quality Report
        
        ## Test Results Summary
        - **Code Quality**: ${{ needs.code-quality.result }}
        - **Unit Tests**: ${{ needs.unit-tests.result }}
        - **Integration Tests**: ${{ needs.integration-tests.result }}
        - **Performance Tests**: ${{ needs.performance-tests.result }}
        
        ## Code Quality Checks
        - âœ… Black formatting
        - âœ… Import sorting (isort)
        - âœ… Code linting (flake8)
        - âœ… Security scan (bandit)
        
        ## Test Coverage
        - Unit tests for preprocessing pipeline
        - Model training and validation tests
        - End-to-end pipeline tests
        - Performance and memory tests
        
        ## Next Steps
        EOF
        
        if [ "${{ needs.code-quality.result }}" == "success" ] && [ "${{ needs.unit-tests.result }}" == "success" ]; then
          echo "- âœ… All tests passed - Ready for deployment" >> test_report.md
        else
          echo "- âŒ Some tests failed - Review and fix issues" >> test_report.md
        fi
        
        echo "EOF" >> test_report.md
        
        echo "âœ… Test report generated"
    
    - name: ğŸ“¤ Upload test report
      uses: actions/upload-artifact@v3
      with:
        name: test-report
        path: test_report.md
        retention-days: 30